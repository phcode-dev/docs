"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1388],{65249:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var i=t(74848),s=t(28453);const r={},o=void 0,d={id:"API-Reference/document/DocumentManager",title:"DocumentManager",description:"Import :",source:"@site/api/API-Reference/document/DocumentManager.md",sourceDirName:"API-Reference/document",slug:"/API-Reference/document/DocumentManager",permalink:"/api/API-Reference/document/DocumentManager",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Document",permalink:"/api/API-Reference/document/"},next:{title:"TextRange",permalink:"/api/API-Reference/document/TextRange"}},c={},l=[{value:"Import :",id:"import-",level:3},{value:"_",id:"_",level:2},{value:"EVENT_AFTER_DOCUMENT_CREATE : <code>string</code>",id:"event_after_document_create--string",level:2},{value:"EVENT_PATH_DELETED : <code>string</code>",id:"event_path_deleted--string",level:2},{value:"EVENT_FILE_NAME_CHANGE : <code>string</code>",id:"event_file_name_change--string",level:2},{value:"EVENT_BEFORE_DOCUMENT_DELETE : <code>string</code>",id:"event_before_document_delete--string",level:2},{value:"EVENT_DOCUMENT_REFRESHED : <code>string</code>",id:"event_document_refreshed--string",level:2},{value:"EVENT_DOCUMENT_CHANGE : <code>string</code>",id:"event_document_change--string",level:2},{value:"EVENT_DIRTY_FLAG_CHANGED : <code>string</code>",id:"event_dirty_flag_changed--string",level:2},{value:"getOpenDocumentForPath(fullPath) \u21d2 <code>Document</code>",id:"getopendocumentforpathfullpath--document",level:2},{value:"getAllOpenDocuments() \u21d2 <code>Array.&lt;Document&gt;</code>",id:"getallopendocuments--arraydocument",level:2},{value:"getDocumentForPath(fullPath, fileObj) \u21d2 <code>$.Promise</code>",id:"getdocumentforpathfullpath-fileobj--promise",level:2},{value:"getDocumentText(file, [checkLineEndings]) \u21d2 <code>$.Promise</code>",id:"getdocumenttextfile-checklineendings--promise",level:2},{value:"createUntitledDocument(counter, fileExt) \u21d2 <code>Document</code>",id:"createuntitleddocumentcounter-fileext--document",level:2}];function a(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"import-",children:"Import :"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const DocumentManager = brackets.getModule("document/DocumentManager")\n'})}),"\n",(0,i.jsx)("a",{name:"_"}),"\n",(0,i.jsx)(n.h2,{id:"_",children:"_"}),"\n",(0,i.jsx)(n.p,{children:"DocumentManager maintains a list of currently 'open' Documents. The DocumentManager is responsible\nfor coordinating document operations and dispatching certain document events."}),"\n",(0,i.jsx)(n.p,{children:"Document is the model for a file's contents; it dispatches events whenever those contents change.\nTo transiently inspect a file's content, simply get a Document and call getText() on it. However,\nto be notified of Document changes or to modify a Document, you MUST call addRef() to ensure the\nDocument instance 'stays alive' and is shared by all other who read/modify that file. ('Open'\nDocuments are all Documents that are 'kept alive', i.e. have ref count > 0)."}),"\n",(0,i.jsx)(n.p,{children:"To get a Document, call getDocumentForPath(); never new up a Document yourself."}),"\n",(0,i.jsx)(n.p,{children:"Secretly, a Document may use an Editor instance to act as the model for its internal state. (This\nis unavoidable because CodeMirror does not separate its model from its UI). Documents are not\nmodifiable until they have a backing 'master Editor'. Creation of the backing Editor is owned by\nEditorManager. A Document only gets a backing Editor if it opened in an editor."}),"\n",(0,i.jsx)(n.p,{children:"A non-modifiable Document may still dispatch change notifications, if the Document was changed\nexternally on disk."}),"\n",(0,i.jsx)(n.p,{children:"Aside from the text content, Document tracks a few pieces of metadata - notably, whether there are\nany unsaved changes."}),"\n",(0,i.jsx)(n.p,{children:"This module dispatches several events:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"dirtyFlagChange -- When any Document's isDirty flag changes. The 2nd arg to the listener is the\nDocument whose flag changed."}),"\n",(0,i.jsx)(n.li,{children:"documentSaved -- When a Document's changes have been saved. The 2nd arg to the listener is the\nDocument that has been saved."}),"\n",(0,i.jsx)(n.li,{children:"documentRefreshed -- When a Document's contents have been reloaded from disk. The 2nd arg to the\nlistener is the Document that has been refreshed."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"NOTE: WorkingSet APIs have been deprecated and have moved to MainViewManager as WorkingSet APIs\nSome WorkingSet APIs that have been identified as being used by 3rd party extensions will\nemit deprecation warnings and call the WorkingSet APIS to maintain backwards compatibility"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"currentDocumentChange -- Deprecated: use EditorManager activeEditorChange (which covers all editors,\nnot just full-sized editors) or MainViewManager currentFileChange (which covers full-sized views\nonly, but is also triggered for non-editor views e.g. image files)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"fileNameChange -- When the name of a file or folder has changed. The 2nd arg is the old name.\nThe 3rd arg is the new name.  Generally, however, file objects have already been changed by the\ntime this event is dispatched so code that relies on matching the filename to a file object\nwill need to compare the newname."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"pathDeleted -- When a file or folder has been deleted. The 2nd arg is the path that was deleted."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'To listen for events, do something like this: (see EventDispatcher for details on this pattern)\nDocumentManager.on("eventname", handler);'}),"\n",(0,i.jsx)(n.p,{children:"Document objects themselves also dispatch some events - see Document docs for details."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global variable"]}),"\n",(0,i.jsx)("a",{name:"EVENT_AFTER_DOCUMENT_CREATE"}),"\n",(0,i.jsxs)(n.h2,{id:"event_after_document_create--string",children:["EVENT_AFTER_DOCUMENT_CREATE : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered after a document is created."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"EVENT_PATH_DELETED"}),"\n",(0,i.jsxs)(n.h2,{id:"event_path_deleted--string",children:["EVENT_PATH_DELETED : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered when a file or folder path is deleted."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"EVENT_FILE_NAME_CHANGE"}),"\n",(0,i.jsxs)(n.h2,{id:"event_file_name_change--string",children:["EVENT_FILE_NAME_CHANGE : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered when a file's name changes."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"EVENT_BEFORE_DOCUMENT_DELETE"}),"\n",(0,i.jsxs)(n.h2,{id:"event_before_document_delete--string",children:["EVENT_BEFORE_DOCUMENT_DELETE : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered before a document is deleted."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"EVENT_DOCUMENT_REFRESHED"}),"\n",(0,i.jsxs)(n.h2,{id:"event_document_refreshed--string",children:["EVENT_DOCUMENT_REFRESHED : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered when a document is refreshed."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"EVENT_DOCUMENT_CHANGE"}),"\n",(0,i.jsxs)(n.h2,{id:"event_document_change--string",children:["EVENT_DOCUMENT_CHANGE : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered when a document's content changes."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"EVENT_DIRTY_FLAG_CHANGED"}),"\n",(0,i.jsxs)(n.h2,{id:"event_dirty_flag_changed--string",children:["EVENT_DIRTY_FLAG_CHANGED : ",(0,i.jsx)("code",{children:"string"})]}),"\n",(0,i.jsx)(n.p,{children:"Event triggered when the document's dirty flag changes,\nindicating if the document has unsaved changes."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global constant"]}),"\n",(0,i.jsx)("a",{name:"getOpenDocumentForPath"}),"\n",(0,i.jsxs)(n.h2,{id:"getopendocumentforpathfullpath--document",children:["getOpenDocumentForPath(fullPath) \u21d2 ",(0,i.jsx)("code",{children:"Document"})]}),"\n",(0,i.jsxs)(n.p,{children:["Returns the existing open Document for the given file, or null if the file is not open ('open'\nmeans referenced by the UI somewhere). If you will hang onto the Document, you must addRef()\nit; see ",(0,i.jsx)(n.a,{href:"#getDocumentForPath",children:"#getDocumentForPath"})," for details."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Param"}),(0,i.jsx)(n.th,{children:"Type"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"fullPath"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"string"})})]})})]}),"\n",(0,i.jsx)("a",{name:"getAllOpenDocuments"}),"\n",(0,i.jsxs)(n.h2,{id:"getallopendocuments--arraydocument",children:["getAllOpenDocuments() \u21d2 ",(0,i.jsx)("code",{children:"Array.<Document>"})]}),"\n",(0,i.jsx)(n.p,{children:"Returns all Documents that are 'open' in the UI somewhere (for now, this means open in an\ninline editor and/or a full-size editor). Only these Documents can be modified, and only\nthese Documents are synced with external changes on disk."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsx)("a",{name:"getDocumentForPath"}),"\n",(0,i.jsxs)(n.h2,{id:"getdocumentforpathfullpath-fileobj--promise",children:["getDocumentForPath(fullPath, fileObj) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(n.p,{children:"Gets an existing open Document for the given file, or creates a new one if the Document is\nnot currently open ('open' means referenced by the UI somewhere). Always use this method to\nget Documents; do not call the Document constructor directly. This method is safe to call\nin parallel."}),"\n",(0,i.jsx)(n.p,{children:"If you are going to hang onto the Document for more than just the duration of a command - e.g.\nif you are going to display its contents in a piece of UI - then you must addRef() the Document\nand listen for changes on it. (Note: opening the Document in an Editor automatically manages\nrefs and listeners for that Editor UI)."}),"\n",(0,i.jsx)(n.p,{children:"If all you need is the Document's getText() value, use the faster getDocumentText() instead."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global function",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Returns"}),": ",(0,i.jsx)("code",{children:"$.Promise"})," - A promise object that will be resolved with the Document, or rejected\nwith a FileSystemError if the file is not yet open and can't be read from disk."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Param"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"fullPath"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"string"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"fileObj"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"object"})}),(0,i.jsx)(n.td,{children:"actual File"})]})]})]}),"\n",(0,i.jsx)("a",{name:"getDocumentText"}),"\n",(0,i.jsxs)(n.h2,{id:"getdocumenttextfile-checklineendings--promise",children:["getDocumentText(file, [checkLineEndings]) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(n.p,{children:"Gets the text of a Document (including any unsaved changes), or would-be Document if the\nfile is not actually open. More efficient than getDocumentForPath(). Use when you're reading\ndocument(s) but don't need to hang onto a Document object."}),"\n",(0,i.jsx)(n.p,{children:"If the file is open this is equivalent to calling getOpenDocumentForPath().getText(). If the\nfile is NOT open, this is like calling getDocumentForPath()...getText() but more efficient.\nDiffers from plain FileUtils.readAsText() in two ways: (a) line endings are still normalized\nas in Document.getText(); (b) unsaved changes are returned if there are any."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global function",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Returns"}),": ",(0,i.jsx)("code",{children:"$.Promise"})," - A promise that is resolved with three parameters:\ncontents - string: the document's text\ntimestamp - Date: the last time the document was changed on disk (might not be the same as the last time it was changed in memory)\nlineEndings - string: the original line endings of the file, one of the FileUtils.LINE_ENDINGS_* constants;\nwill be null if checkLineEndings was false.\nor rejected with a filesystem error."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Param"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"file"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"File"})}),(0,i.jsx)(n.td,{children:"The file to get the text for."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"[checkLineEndings]"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"boolean"})}),(0,i.jsx)(n.td,{children:"Whether to return line ending information. Default false (slightly more efficient)."})]})]})]}),"\n",(0,i.jsx)("a",{name:"createUntitledDocument"}),"\n",(0,i.jsxs)(n.h2,{id:"createuntitleddocumentcounter-fileext--document",children:["createUntitledDocument(counter, fileExt) \u21d2 ",(0,i.jsx)("code",{children:"Document"})]}),"\n",(0,i.jsx)(n.p,{children:"Creates an untitled document. The associated File has a fullPath that\nlooks like /some-random-string/Untitled-counter.fileExt."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kind"}),": global function",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Returns"}),": ",(0,i.jsx)("code",{children:"Document"})," - - a new untitled Document"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Param"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"counter"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"number"})}),(0,i.jsx)(n.td,{children:"used in the name of the new Document's File"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"fileExt"}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"string"})}),(0,i.jsx)(n.td,{children:'file extension of the new Document\'s File, including "."'})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);