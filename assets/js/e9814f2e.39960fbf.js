"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7377],{54869:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var i=n(74848),r=n(28453);const t={},l=void 0,o={id:"API-Reference/utils/Async",title:"Async",description:"Import :",source:"@site/api/API-Reference/utils/Async.md",sourceDirName:"API-Reference/utils",slug:"/API-Reference/utils/Async",permalink:"/api/API-Reference/utils/Async",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AppInit",permalink:"/api/API-Reference/utils/AppInit"},next:{title:"ColorUtils",permalink:"/api/API-Reference/utils/ColorUtils"}},d={},c=[{value:"Import :",id:"import-",level:3},{value:"PromiseQueue",id:"promisequeue",level:2},{value:"new PromiseQueue()",id:"new-promisequeue",level:3},{value:"promiseQueue.add(op)",id:"promisequeueaddop",level:3},{value:"promiseQueue.removeAll()",id:"promisequeueremoveall",level:3},{value:"ERROR_TIMEOUT : <code>Object</code>",id:"error_timeout--object",level:2},{value:"doInParallel(items, beginProcessItem, failFast) \u21d2 <code>$.Promise</code>",id:"doinparallelitems-beginprocessitem-failfast--promise",level:2},{value:"doSequentially(items, beginProcessItem, failAndStopFast) \u21d2 <code>$.Promise</code>",id:"dosequentiallyitems-beginprocessitem-failandstopfast--promise",level:2},{value:"doSequentiallyInBackground(items, fnProcessItem, [maxBlockingTime], [idleTime]) \u21d2 <code>$.Promise</code>",id:"dosequentiallyinbackgrounditems-fnprocessitem-maxblockingtime-idletime--promise",level:2},{value:"firstSequentially(items, beginProcessItem) \u21d2 <code>$.Promise</code>",id:"firstsequentiallyitems-beginprocessitem--promise",level:2},{value:"doInParallel_aggregateErrors(items, beginProcessItem) \u21d2 <code>$.Promise</code>",id:"doinparallel_aggregateerrorsitems-beginprocessitem--promise",level:2},{value:"withTimeout(promise, timeout, [resolveTimeout]) \u21d2 <code>$.Promise</code>",id:"withtimeoutpromise-timeout-resolvetimeout--promise",level:2},{value:"waitForAll(promises, [failOnReject], [timeout]) \u21d2 <code>$.Promise</code>",id:"waitforallpromises-failonreject-timeout--promise",level:2},{value:"chain(functions, args) \u21d2 <code>jQuery.Promise</code>",id:"chainfunctions-args--jquerypromise",level:2},{value:"promisify(obj, method, ...varargs) \u21d2 <code>$.Promise</code>",id:"promisifyobj-method-varargs--promise",level:2}];function a(e){const s={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h3,{id:"import-",children:"Import :"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'const Async = brackets.getModule("utils/Async")\n'})}),"\n",(0,i.jsx)("a",{name:"PromiseQueue"}),"\n",(0,i.jsx)(s.h2,{id:"promisequeue",children:"PromiseQueue"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global class"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"#PromiseQueue",children:"PromiseQueue"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#new_PromiseQueue_new",children:"new PromiseQueue()"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#PromiseQueue+add",children:".add(op)"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#PromiseQueue+removeAll",children:".removeAll()"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)("a",{name:"new_PromiseQueue_new"}),"\n",(0,i.jsx)(s.h3,{id:"new-promisequeue",children:"new PromiseQueue()"}),"\n",(0,i.jsx)(s.p,{children:"Creates a queue of async operations that will be executed sequentially. Operations can be added to the\nqueue at any time. If the queue is empty and nothing is currently executing when an operation is added,\nit will execute immediately. Otherwise, it will execute when the last operation currently in the queue\nhas finished."}),"\n",(0,i.jsx)("a",{name:"PromiseQueue+add"}),"\n",(0,i.jsx)(s.h3,{id:"promisequeueaddop",children:"promiseQueue.add(op)"}),"\n",(0,i.jsx)(s.p,{children:"Adds an operation to the queue. If nothing is currently executing, it will execute immediately (and\nthe next operation added to the queue will wait for it to complete). Otherwise, it will wait until\nthe last operation in the queue (or the currently executing operation if nothing is in the queue) is\nfinished. The operation must return a promise that will be resolved or rejected when it's finished;\nthe queue will continue with the next operation regardless of whether the current operation's promise\nis resolved or rejected."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": instance method of ",(0,i.jsx)(s.a,{href:"#PromiseQueue",children:(0,i.jsx)("code",{children:"PromiseQueue"})})]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"op"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"function"})}),(0,i.jsx)(s.td,{children:"The operation to add to the queue."})]})})]}),"\n",(0,i.jsx)("a",{name:"PromiseQueue+removeAll"}),"\n",(0,i.jsx)(s.h3,{id:"promisequeueremoveall",children:"promiseQueue.removeAll()"}),"\n",(0,i.jsx)(s.p,{children:"Removes all pending promises from the queue."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": instance method of ",(0,i.jsx)(s.a,{href:"#PromiseQueue",children:(0,i.jsx)("code",{children:"PromiseQueue"})})]}),"\n",(0,i.jsx)("a",{name:"ERROR_TIMEOUT"}),"\n",(0,i.jsxs)(s.h2,{id:"error_timeout--object",children:["ERROR_TIMEOUT : ",(0,i.jsx)("code",{children:"Object"})]}),"\n",(0,i.jsx)(s.p,{children:"Value passed to fail() handlers that have been triggered due to withTimeout()'s timeout"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global variable"]}),"\n",(0,i.jsx)("a",{name:"doInParallel"}),"\n",(0,i.jsxs)(s.h2,{id:"doinparallelitems-beginprocessitem-failfast--promise",children:["doInParallel(items, beginProcessItem, failFast) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:'Executes a series of tasks in parallel, returning a "master" Promise that is resolved once\nall the tasks have resolved. If one or more tasks fail, behavior depends on the failFast\nflag:'}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"If true, the master Promise is rejected as soon as the first task fails. The remaining\ntasks continue to completion in the background."}),"\n",(0,i.jsx)(s.li,{children:"If false, the master Promise is rejected after all tasks have completed."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"If nothing fails:          (M = master promise; 1-4 = tasks; d = done; F = fail)\nM  ------------d\n1 >---d        .\n2 >------d     .\n3 >---------d  .\n4 >------------d"}),"\n",(0,i.jsx)(s.p,{children:"With failFast = false:\nM  ------------F\n1 >---d     .  .\n2 >------d  .  .\n3 >---------F  .\n4 >------------d"}),"\n",(0,i.jsx)(s.p,{children:"With failFast = true: -- equivalent to $.when()\nM  ---------F\n1 >---d     .\n2 >------d  .\n3 >---------F\n4 >------------d   (#4 continues even though master Promise has failed)\n(Note: if tasks finish synchronously, the behavior is more like failFast=false because you\nwon't get a chance to respond to the master Promise until after all items have been processed)"}),"\n",(0,i.jsx)(s.p,{children:"To perform task-specific work after an individual task completes, attach handlers to each\nPromise before beginProcessItem() returns it."}),"\n",(0,i.jsx)(s.p,{children:"Note: don't use this if individual tasks (or their done/fail handlers) could ever show a user-\nvisible dialog: because they run in parallel, you could show multiple dialogs atop each other."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"items"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<*>"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"beginProcessItem"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"function"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"failFast"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"boolean"})})]})]})]}),"\n",(0,i.jsx)("a",{name:"doSequentially"}),"\n",(0,i.jsxs)(s.h2,{id:"dosequentiallyitems-beginprocessitem-failandstopfast--promise",children:["doSequentially(items, beginProcessItem, failAndStopFast) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:'Executes a series of tasks in serial (task N does not begin until task N-1 has completed).\nReturns a "master" Promise that is resolved once all the tasks have resolved. If one or more\ntasks fail, behavior depends on the failAndStopFast flag:'}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"If true, the master Promise is rejected as soon as the first task fails. The remaining\ntasks are never started (the serial sequence is stopped)."}),"\n",(0,i.jsx)(s.li,{children:"If false, the master Promise is rejected after all tasks have completed."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"If nothing fails:\nM  ------------d\n1 >---d        .\n2     >--d     .\n3        >--d  .\n4           >--d"}),"\n",(0,i.jsx)(s.p,{children:"With failAndStopFast = false:\nM  ------------F\n1 >---d     .  .\n2     >--d  .  .\n3        >--F  .\n4           >--d"}),"\n",(0,i.jsx)(s.p,{children:"With failAndStopFast = true:\nM  ---------F\n1 >---d     .\n2     >--d  .\n3        >--F\n4          (#4 never runs)"}),"\n",(0,i.jsx)(s.p,{children:"To perform task-specific work after an individual task completes, attach handlers to each\nPromise before beginProcessItem() returns it."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"items"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<*>"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"beginProcessItem"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"function"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"failAndStopFast"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"boolean"})})]})]})]}),"\n",(0,i.jsx)("a",{name:"doSequentiallyInBackground"}),"\n",(0,i.jsxs)(s.h2,{id:"dosequentiallyinbackgrounditems-fnprocessitem-maxblockingtime-idletime--promise",children:["doSequentiallyInBackground(items, fnProcessItem, [maxBlockingTime], [idleTime]) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:"Executes a series of synchronous tasks sequentially spread over time-slices less than maxBlockingTime.\nProcessing yields by idleTime between time-slices."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"items"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<*>"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"fnProcessItem"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"function"})}),(0,i.jsx)(s.td,{children:"Function that synchronously processes one item"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"[maxBlockingTime]"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"number"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"[idleTime]"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"number"})}),(0,i.jsx)(s.td,{})]})]})]}),"\n",(0,i.jsx)("a",{name:"firstSequentially"}),"\n",(0,i.jsxs)(s.h2,{id:"firstsequentiallyitems-beginprocessitem--promise",children:["firstSequentially(items, beginProcessItem) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:'Executes a series of tasks in serial (task N does not begin until task N-1 has completed).\nReturns a "master" Promise that is resolved when the first task has resolved. If all tasks\nfail, the master Promise is rejected.'}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"items"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<*>"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"beginProcessItem"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"function"})})]})]})]}),"\n",(0,i.jsx)("a",{name:"doInParallel_aggregateErrors"}),"\n",(0,i.jsxs)(s.h2,{id:"doinparallel_aggregateerrorsitems-beginprocessitem--promise",children:["doInParallel_aggregateErrors(items, beginProcessItem) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:"Executes a series of tasks in parallel, saving up error info from any that fail along the way.\nReturns a Promise that is only resolved/rejected once all tasks are complete. This is\nessentially a wrapper around doInParallel(..., false)."}),"\n",(0,i.jsx)(s.p,{children:'If one or more tasks failed, the entire "master" promise is rejected at the end - with one\nargument: an array objects, one per failed task. Each error object contains:'}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"item -- the entry in items whose task failed"}),"\n",(0,i.jsx)(s.li,{children:"error -- the first argument passed to the fail() handler when the task failed"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"items"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<*>"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"beginProcessItem"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"function"})})]})]})]}),"\n",(0,i.jsx)("a",{name:"withTimeout"}),"\n",(0,i.jsxs)(s.h2,{id:"withtimeoutpromise-timeout-resolvetimeout--promise",children:["withTimeout(promise, timeout, [resolveTimeout]) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:"Adds timeout-driven termination to a Promise: returns a new Promise that is resolved/rejected when\nthe given original Promise is resolved/rejected, OR is resolved/rejected after the given delay -\nwhichever happens first."}),"\n",(0,i.jsx)(s.p,{children:"If the original Promise is resolved/rejected first, done()/fail() handlers receive arguments\npiped from the original Promise. If the timeout occurs first instead, then resolve() or\nfail() (with Async.ERROR_TIMEOUT) is called based on value of resolveTimeout."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"promise"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"$.Promise"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"timeout"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"number"})}),(0,i.jsx)(s.td,{})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"[resolveTimeout]"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"boolean"})}),(0,i.jsx)(s.td,{children:"If true, then resolve deferred on timeout, otherwise reject. Default is false."})]})]})]}),"\n",(0,i.jsx)("a",{name:"waitForAll"}),"\n",(0,i.jsxs)(s.h2,{id:"waitforallpromises-failonreject-timeout--promise",children:["waitForAll(promises, [failOnReject], [timeout]) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:"Allows waiting for all the promises to be either resolved or rejected.\nUnlike $.when(), it does not call .fail() or .always() handlers on first\nreject. The caller should take all the precaution to make sure all the\npromises passed to this function are completed to avoid blocking."}),"\n",(0,i.jsx)(s.p,{children:"If failOnReject is set to true, promise returned by the function will be\nrejected if at least one of the promises was rejected. The default value\nis false, which will cause the call to this function to be always\nsuccessfully resolved."}),"\n",(0,i.jsx)(s.p,{children:"If timeout is specified, the promise will be rejected on timeout as per\nAsync.withTimeout."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Returns"}),": ",(0,i.jsx)("code",{children:"$.Promise"})," - A Promise which will be resolved once all dependent promises are resolved.\nIt is resolved with an array of results from the successfully resolved dependent promises.\nThe resulting array may not be in the same order or contain as many items as there were\npromises to wait on and it will contain 'undefined' entries for those promises that resolve\nwithout a result."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"promises"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<$.Promise>"})}),(0,i.jsx)(s.td,{children:"Array of promises to wait for"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"[failOnReject]"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"boolean"})}),(0,i.jsx)(s.td,{children:"Whether to reject or not if one of the promises has been rejected."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"[timeout]"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"number"})}),(0,i.jsx)(s.td,{children:"Number of milliseconds to wait until rejecting the promise"})]})]})]}),"\n",(0,i.jsx)("a",{name:"chain"}),"\n",(0,i.jsxs)(s.h2,{id:"chainfunctions-args--jquerypromise",children:["chain(functions, args) \u21d2 ",(0,i.jsx)("code",{children:"jQuery.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:"Chains a series of synchronous and asynchronous (jQuery promise-returning) functions\ntogether, using the result of each successive function as the argument(s) to the next.\nA promise is returned that resolves with the result of the final call if all calls\nresolve or return normally. Otherwise, if any of the functions reject or throw, the\ncomputation is halted immediately and the promise is rejected with this halting error."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Returns"}),": ",(0,i.jsx)("code",{children:"jQuery.Promise"})," - A promise that resolves with the result of the final call, or\nrejects with the first error."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"functions"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array.<function(*)>"})}),(0,i.jsx)(s.td,{children:"Functions to be chained"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"args"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Array"})}),(0,i.jsx)(s.td,{children:"Arguments to call the first function with"})]})]})]}),"\n",(0,i.jsx)("a",{name:"promisify"}),"\n",(0,i.jsxs)(s.h2,{id:"promisifyobj-method-varargs--promise",children:["promisify(obj, method, ...varargs) \u21d2 ",(0,i.jsx)("code",{children:"$.Promise"})]}),"\n",(0,i.jsx)(s.p,{children:"Utility for converting a method that takes (error, callback) to one that returns a promise;\nuseful for using FileSystem methods (or other Node-style API methods) in a promise-oriented\nworkflow. For example, instead of"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"     var deferred = new $.Deferred();\n     file.read(function (err, contents) {\n         if (err) {\n             deferred.reject(err);\n         } else {\n             // ...process the contents...\n             deferred.resolve();\n         }\n     }\n     return deferred.promise();\n"})}),"\n",(0,i.jsx)(s.p,{children:"you can just do"}),"\n",(0,i.jsxs)(s.p,{children:['return Async.promisify(file, "read").then(function (contents) ',");"]}),"\n",(0,i.jsx)(s.p,{children:'The object/method are passed as an object/string pair so that we can\nproperly call the method without the caller having to deal with "bind" all the time.'}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Kind"}),": global function",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Returns"}),": ",(0,i.jsx)("code",{children:"$.Promise"})," - A promise that is resolved with the arguments that were passed to the\nerrback (not including the err argument) if err is null, or rejected with the err if\nnon-null."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Param"}),(0,i.jsx)(s.th,{children:"Type"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"obj"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Object"})}),(0,i.jsx)(s.td,{children:"The object to call the method on."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"method"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"string"})}),(0,i.jsx)(s.td,{children:"The name of the method. The method should expect the errback      as its last parameter."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"...varargs"}),(0,i.jsx)(s.td,{children:(0,i.jsx)("code",{children:"Object"})}),(0,i.jsx)(s.td,{children:"The arguments you would have normally passed to the method      (excluding the errback itself)."})]})]})]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>o});var i=n(96540);const r={},t=i.createContext(r);function l(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);